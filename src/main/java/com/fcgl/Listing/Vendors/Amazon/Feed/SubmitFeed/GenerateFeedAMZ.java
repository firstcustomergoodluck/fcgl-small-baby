package com.fcgl.Listing.Vendors.Amazon.Feed.SubmitFeed;
//Amazon Imports

import com.amazonaws.mws.MarketplaceWebService;
import com.amazonaws.mws.MarketplaceWebServiceException;
import com.amazonaws.mws.model.FeedSubmissionInfo;
import com.amazonaws.mws.model.IdList;
import com.amazonaws.mws.model.ResponseMetadata;
import com.amazonaws.mws.model.SubmitFeedRequest;
import com.amazonaws.mws.model.SubmitFeedResponse;
import com.amazonaws.mws.model.SubmitFeedResult;
import com.fcgl.Exceptions.RetryLimitException;
import com.fcgl.Listing.Response.Response;
import com.fcgl.Listing.Vendors.Amazon.AbstractAMZService;
import com.fcgl.Listing.Vendors.IGenerateFeed;
import com.fcgl.Listing.Vendors.model.IProductInformation;
import com.fcgl.MessageQueue.IMessageQueueSender;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.Arrays;
import java.util.List;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

//Java Imports
//FCGL Imports WHAT

//TODO: Need to add a log under every error
//TODO: Need to add a log after a successful API call
//TODO: Need to set up RabbitMQ for message queues.
//TODO: Need to backlog xml file location if there were no errors in XML but there was an error in submission.
//TODO: Look at third parties for XML generators

/**
 * Submits a Feed on Amazon. Workflow: 1. Gets Product Data from Message Queue 2. Generates XML File
 * with data that was returned from Message Queue 3. Calls Amazon's submitFeed API
 */
public class GenerateFeedAMZ extends AbstractAMZService implements IGenerateFeed {

  private final String requestId;    //TODO: Need to move all of these to a config file and make it secret (look up 3rd party encryption)
  private final String MWSAuthToken = "";
  private final String merchantId = "";
  private final String marketplaceId = "";
  private final int[] retryWaitTime = {1000, 4000, 16000, 30000};//This was recommended by Amazon
  private static final Logger logger = LogManager.getLogger("GenerateFeedAMZ");
  private IMessageQueueSender messageQueueSender;
  private final String FEED_SUBMISSION_QUEUE = "FeedProcessing";
  private final String FAILED_XML_UPLOAD = "XMLLocation";

  /**
   * GenerateFeedAMZ constructor
   *
   * @param requestId: The requestId generated by the CRON Job.
   */
  public GenerateFeedAMZ(String requestId, IMessageQueueSender messageQueueSender) {
    this.requestId = requestId;
    this.messageQueueSender = messageQueueSender;
  }

  /**
   * Completes the entire workflow. Gets Product Data, Generates XML, Calls AMAZON API.
   *
   * @return Response returned by Amazon Marketplace Web Services
   */
  public Response generateFeed(List<IProductInformation> productInformation) {
    MarketplaceWebService service = instantiateService();// Instantiates MWS service
    String fileLocation = generateProductXML(
        productInformation);//Generates an xml file for the product information

    try {
      return submitFeed(fileLocation, service, 0);
    } catch (RetryLimitException e) {
      String message = e.getMessage();
      int statusCode = 500;
      return new Response(true, statusCode, getRequestId(), message);
    } catch (InterruptedException e) {
      //do some retry logic
      return new Response(true, 400, getRequestId(), e.getMessage());
    }
  }

  /**
   * Generates an XML file with the product information passed into this method.
   *
   * @param productInformation: The product data returned from the message queue.
   * @return the full path of the location of the XML file that was generated.
   */
  private String generateProductXML(List<IProductInformation> productInformation) {
    //IXMLGenerator productXML = new XMLGeneratorAMZ();
    //return productXML.generateProductXML(productInformation, getRequestId());
    return null;
  }

  /**
   * Generates the request for submitting a feed Throttling: Request Quota: 15 requests, Restore
   * Rate: 1 request every 2 minutes, Hourly quota: 30 requests Amazon Docs:
   * http://docs.developer.amazonservices.com/en_US/feeds/Feeds_SubmitFeed.html
   *
   * @param fileLocation: the file location of the product feed
   * @param service: A MarketplaceWebService instance
   * @param retryAttempt: The number of times the Amazon API will be called when there is a server
   * error
   * @return Response: A Response is one of SubmitFeedSuccessAMZ or ErrorHandlerAMZ.
   * @throws RetryLimitException: Will be thrown when the retry limit is reached
   * @throws InterruptedException: Thread error
   */
  //TODO: Update retry logic to be consistent to how we do the rest...
  private Response submitFeed(String fileLocation, MarketplaceWebService service, int retryAttempt)
      throws RetryLimitException, InterruptedException {
    IdList marketplaces = new IdList(Arrays.asList(marketplaceId));
    SubmitFeedRequest request = new SubmitFeedRequest();
    request.setMerchant(merchantId);
    request.setMWSAuthToken(MWSAuthToken);
    request.setMarketplaceIdList(marketplaces);
    request.setFeedType("_POST_PRODUCT_DATA_");

    try {
      request.setFeedContent(new FileInputStream(fileLocation));
    } catch (FileNotFoundException e) {
      e.printStackTrace();
      //TODO: This is a really bad error...
      String message = String
          .format("The file: %s was not found, try regenerating the file", fileLocation);
      int statusCode = 404;

      return new Response(true, statusCode, getRequestId(), message);
    }

    Response invokeSubmitFeedResponse = invokeSubmitFeed(service, request);

    //Does some retry logic to handle throttling or server errors
    if (invokeSubmitFeedResponse.isError()) {
      int statusCode = invokeSubmitFeedResponse.getStatusCode();
      if (retryAttempt > 4) {
        messageQueueSender.sendMessage(fileLocation, FAILED_XML_UPLOAD);
        throw new RetryLimitException("Retry Attempts Exceeded for submitFeed()");
      }

      if (statusCode >= 500) {
        Thread.sleep(retryWaitTime[retryAttempt]);
        submitFeed(fileLocation, service, retryAttempt++);
      }
    }

    return invokeSubmitFeedResponse;
  }


  /**
   * Submit Feed request Uploads a file for processing together with the necessary metadata
   * to process the file, such as which type of feed it is. PurgeAndReplace if true means that your
   * existing e.g. inventory is wiped out and replace with the contents of this feed - use with
   * caution (the default is false).
   *
   * Sends the FeedSubmissionId to a queue for later processing
   * TODO: Should save FeedSubmissionId to database
   * @param service: instance of MarketplaceWebService service
   * @param request: a SubmitFeedRequest
   * @return Response Object
   */
  private Response invokeSubmitFeed(MarketplaceWebService service, SubmitFeedRequest request) {
    try {
      StringBuilder builder = new StringBuilder();
      String amzFeedSubmissionid = "";
      String amzProcessingStatus = "";
      String timestamp = "";
      String amzRequestId = "";
      int statusCode;

      SubmitFeedResponse response = service.submitFeedFromFile(request);
      builder.append("SubmitFeed Header\n");
      builder.append("SubmitFeed Action Response\n");
      builder.append("=============================================================================\n\n");
      builder.append("    SubmitFeedResponse\n");
      if (response.isSetSubmitFeedResult()) {
        builder.append("        SubmitFeedResult\n");
        SubmitFeedResult submitFeedResult = response
            .getSubmitFeedResult();
        if (submitFeedResult.isSetFeedSubmissionInfo()) {
          builder.append("            FeedSubmissionInfo\n");
          FeedSubmissionInfo feedSubmissionInfo = submitFeedResult
              .getFeedSubmissionInfo();
          if (feedSubmissionInfo.isSetFeedSubmissionId()) {
            amzFeedSubmissionid = feedSubmissionInfo.getFeedSubmissionId();
            builder.append("                FeedSubmissionId\n");
            builder.append("                    ");
            builder.append(amzFeedSubmissionid);
            builder.append("\n");
          }
          if (feedSubmissionInfo.isSetFeedType()) {
            builder.append("                FeedType\n");
            builder.append("                    ");
            builder.append(feedSubmissionInfo.getFeedType());
            builder.append("\n");
          }
          if (feedSubmissionInfo.isSetSubmittedDate()) {
            builder.append("                SubmittedDate\n");
            builder.append("                    ");
            builder.append("                    ");
            builder.append(feedSubmissionInfo.getSubmittedDate());
            builder.append("\n");
          }
          if (feedSubmissionInfo.isSetFeedProcessingStatus()) {
            amzProcessingStatus = feedSubmissionInfo.getFeedSubmissionId();
            builder.append("                FeedProcessingStatus\n");
            builder.append("                    ");
            builder.append(amzProcessingStatus);
            builder.append("\n");
          }
          if (feedSubmissionInfo.isSetStartedProcessingDate()) {
            builder.append("                StartedProcessingDate\n");
            builder.append("                    ");
            builder.append(feedSubmissionInfo.getStartedProcessingDate());
            builder.append("\n");
          }
          if (feedSubmissionInfo.isSetCompletedProcessingDate()) {
            builder.append("                CompletedProcessingDate\n");
            builder.append("                    ");
            builder.append(feedSubmissionInfo.getCompletedProcessingDate());
            builder.append("\n");
          }
        }
      }
      if (response.isSetResponseMetadata()) {
        builder.append("        ResponseMetadata\n");
        ResponseMetadata responseMetadata = response.getResponseMetadata();
        if (responseMetadata.isSetRequestId()) {
          amzRequestId = responseMetadata.getRequestId();
          builder.append("            RequestId\n");
          builder.append("                ");
          builder.append(amzRequestId);
          builder.append("\n");
        }
      }
      builder.append(response.getResponseHeaderMetadata());
      builder.append("\n\n\n");
      logger.info(builder.toString());
      timestamp = response.getResponseHeaderMetadata().getTimestamp();
      statusCode = 200;
      //TODO: Don't know if other vendors follow same logic, for now make it Amazon specific
      messageQueueSender.sendMessage(amzFeedSubmissionid, FEED_SUBMISSION_QUEUE);
      String message = String.format("SubmitFeed Request Success:" +
              " Status Code: %d," +
              " AMZRequestId: %s," +
              " Feed Submission Id: %s," +
              " Processing Status: %s," +
              " timestamp: %s", statusCode, amzRequestId, amzFeedSubmissionid, amzProcessingStatus,
          timestamp);

      return new Response(false, statusCode, getRequestId(), message);

    } catch (MarketplaceWebServiceException ex) {
      //TODO: This can be taken out... handler does the same logic now
      StringBuilder builder = new StringBuilder();
      String message = ex.getMessage();
      int statusCode = ex.getStatusCode();
      String amzErrorCode = ex.getErrorCode();
      String amzErrorType = ex.getErrorType();
      String amzRequestId = ex.getRequestId();
      String timestamp = ex.getResponseHeaderMetadata().getTimestamp();
      builder.append("Caught Exception: ");
      builder.append(message);
      builder.append("\nResponse Status Code: ");
      builder.append(ex.getStatusCode());
      builder.append("\nError Code: ");
      builder.append(amzErrorCode);
      builder.append("\nError Type: ");
      builder.append(amzErrorType);
      builder.append("\nRequest ID: ");
      builder.append(amzRequestId);
      builder.append("\nTimestamp: ");
      builder.append(timestamp);
      builder.append("\nXML: ");
      builder.append(ex.getXML());
      builder.append("\nResponseHeaderMetadata: ");
      builder.append(ex.getResponseHeaderMetadata());
      builder.append("\n");
      logger.error(builder.toString());

      return new Response(true, statusCode, getRequestId(), message);

    }
  }

  private String getRequestId() {
    return requestId;
  }
}
